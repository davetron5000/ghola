{
  "version": 3,
  "sources": ["../node_modules/brutaldom/src/js/TypeOf.js", "../node_modules/brutaldom/src/js/Log.js", "../node_modules/brutaldom/src/js/BrutalDOMBase.js", "../node_modules/brutaldom/src/js/WrapsElement.js", "../node_modules/brutaldom/src/js/Body.js", "../node_modules/brutaldom/src/js/Template.js", "../node_modules/brutaldom/src/js/Component.js", "../node_modules/brutaldom/src/js/HumanizedString.js", "../node_modules/brutaldom/src/js/EventAlreadyDefined.js", "../node_modules/brutaldom/src/js/EventManager.js", "../node_modules/brutaldom/src/js/Link.js", "../node_modules/brutaldom/src/js/Env.js", "../node_modules/brutaldom/src/js/Runtime.js", "../node_modules/brutaldom/src/js/LogViewer.js", "../src/js/albers.js"],
  "sourcesContent": ["/**\n * Given an object, attempts to return a string that names its type or class.\n *\n */\nclass TypeOf {\n  /**\n   * Get the type of the given value.  This will check if its a function, and use the name. If it has a constructor, it will use\n   * that constructor's name, otherwise it will use whatever typeof returns.  This will swallow any errors.\n   *\n   * @param {Object} value - anything\n   */\n  constructor(value) {\n    this.typeName = typeof value\n    try {\n      if ( ( (typeof value) === \"function\") && value.name ) {\n        this.typeName = value.name\n      }\n      else if (value && value.constructor && value.constructor.name) {\n        this.typeName = value.constructor.name\n      }\n    }\n    catch (error) {\n      console.error(error)\n    }\n  }\n\n  /** @returns {String} the string for the name of this type */\n  toString() { return this.typeName }\n\n  /** @returns the String of a value, skipping the need to create and hold onto an instance of this class */\n  static asString(value) {\n    return new TypeOf(value).toString()\n  }\n}\nexport default TypeOf\n", "import TypeOf from \"./TypeOf\"\n\n/**\n * Convienience methods for tracing/logging method behavior.  This is mixed-into BrutalDOMBase so should\n * be available to all your classes.  This ultimately wraps the Performance API for UserPerformance.\n *\n * The primary way to use this is to call methodStart, then event any number of times, and finally methodDone.  These methods\n * all accept details objects and these are compounded, so that methodDone will include ALL details recorded during the method.\n * This allows you to build up context about what happened inside the method.\n *\n * @mixin\n * @see BrutalDOMBase\n * @see {external:Performance}\n */\nconst LogMixin = {\n\n  /** Used to log the start of a method for later measurement of the method's duration.\n   *\n   * @param {String} methodName - name of the method that just got called\n   * @param {Object} details - passed to performance.mark\n   */\n  methodStart(methodName,details) {\n    this.event(`${methodName}#called`,details)\n  },\n\n  /** Used to log the end of a method. You must have called methodStart. This will\n   * record an event and a measurement\n   *\n   * @param {String} methodName - name of the method that just got called\n   * @param {Object} details - passed to performance.mark and performance.measure\n   *\n   */\n  methodDone(methodName,details) {\n    this.event(`${methodName}#completed`,details)\n    this.measure(methodName,`${methodName}#called`,`${methodName}#completed`)\n  },\n  /**\n   * Record an event via performance.mark\n   *\n   * @param {String} eventName - name of the event - can be anything\n   * @param {Object} details - passed to performance.mark and performance.measure. Added to the default details this mixin stores.\n   */\n  event(eventName,details) {\n    details = {...this.__defaultDetails(), ...details }\n    performance.mark(this._name(eventName),{ detail: details })\n    this.__logMixinDetails = {...this.__logMixinDetails, ...details}\n  },\n  /**\n   * Record a measurement with performance.measure\n   *\n   * @param {String} measurementName - name of the measurement. Can be anything.\n   * @param {String} start - the start mark name, as used in the Performance API\n   * @param {String} end - the end mark name, as used in the Performance API\n   */\n  measure(measurementName,start,end) {\n    if (!start) {\n      throw `You forgot to add start & end to measure(${measurementName})`\n    }\n    else if (!end) {\n      throw `You forgot to add end to measure(${measurementName})`\n    }\n\n    performance.measure(this._name(measurementName),\n      {\n        start: this._name(start),\n        end: this._name(end),\n        detail: this.__logMixinDetails \n      }\n    )\n  },\n  _name(eventName) {\n    if ( (this.constructor) && (this.constructor.logContext) ) {\n      return `${this.constructor.logContext}.${this.__className()}.${eventName}`\n    }\n    else {\n      return `${this.__className()}.${eventName}`\n    }\n  },\n  __defaultDetails() {\n    const details = {\n      logContext: this.constructor.logContext || \"UNKNOWN\",\n      className: this.__className(),\n    }\n    if (window && window.location) {\n      details[`window.location.pathname`] = window.location.pathname\n    }\n    return details\n  },\n  __className() {\n    return TypeOf.asString(this)\n  },\n\n  /** Mixes this into any class\n   * @param {Class} klass - a Class\n   */\n  mixin(klass) {\n    Object.assign(klass.prototype,LogMixin)\n  }\n}\nexport default LogMixin\n", "import Log from \"./Log\"\n\n/**\n * One base class to rule them all. This was created to automatically add\n * the log mixin to all lib classes where relevant plus set the log context appropriately.\n *\n * @mixes Log\n */\nclass BrutalDOMBase {\n  static logContext = \"brutaldom\"\n  constructor() {\n    Log.mixin(this.constructor)\n  }\n}\nexport default BrutalDOMBase\n", "import BrutalDOMBase from \"./BrutalDOMBase\"\n/**\n * Base class for wrapping a DOM element to provide logic.  This is the core class of the library and \n * provides a few convienience methods useful when interacting with the DOM.\n *\n * In general, you likely want to use Component as your base class. See docs there.\n *\n * @see Component\n * @extends BrutalDOMBase\n */\nclass WrapsElement extends BrutalDOMBase {\n  /**\n   * Create the wrapped element.\n   *\n   * @param {external:Element} Element to wrap\n   */\n  constructor(element,...args) {\n    super()\n    this.element = element\n    if (this.wasCreated) {\n      this.wasCreated(...args)\n    }\n  }\n\n  /**\n   * Called with no arguments\n   * @callback WrapsElement~whenNotFound\n   */\n\n  /**\n   * Called with no arguments\n   * @callback WrapsElement~whenMultipleFound\n   * @param {Number} number of elements found.  Will be greater than 1.\n   */\n\n  /** Access an element relvative to this component's element based on\n   *  a selector as you'd use for querySelectorAll() or querySelector()\n   *\n   *  It is expected to return exactly one element and will blow up if it does not\n   *  locate exactly one.\n   *\n   *  If exactly on element is not found, by default an error is thrown. You can\n   *  customize this behavior by providing whenNotFound and/or whenMultipleFound.\n   *\n   *  @param {String} selector -  A selector compatible wiht querySelectorAll or querySelector\n   *  @param {external:Element} baseElement -  if omitted, uses this component's element. If given, uses it\n   *                as the basis for the search.\n   *  @param {WrapsElement~whenNotFound} whenNotFound -  if provided, will be called if no elements matching the selector\n   *                 are found. No arguments given.\n   *  @param {WrapsElement~whenMultipleFound} whenMultipleFound -  if provided, will be called if more than one element matching\n   *                      the selector is found. Given an argument with the number of elements found.\n   *                  \n   *  @returns {external:Element} Return the element located.  Return value is undefined if whenNotFound or whenMultipleFound are\n   *  called.\n   *\n   *  @throws an error if no elements matched and whenNotFound was not provided, OR if more than one element matched and\n   *  whenMultipleFound was not provided.\n   *\n   */\n  $selector(selector,baseElement,whenNotFound,whenMultipleFound) {\n    if (!baseElement) {\n      baseElement = this.element\n    }\n    if ( !(baseElement instanceof Element) && !(baseElement instanceof Document) ) {\n      throw `Base element should be an Element or Document. Got ${JSON.stringify(baseElement)}`\n    }\n    if (!whenNotFound) {\n      whenNotFound = () => {\n          throw `Could not find '${selector}' from ${baseElement.outerHTML}`\n      }\n    }\n    if (!whenMultipleFound) {\n      whenMultipleFound = (numFound) => {\n        throw `Found ${numFound} nodes instead of 1 matching '${selector}' from ${baseElement.outerHTML}`\n      }\n    }\n\n    const elements = baseElement.querySelectorAll(selector)\n\n    if (elements.length == 1) {\n      return elements.item(0);\n    }\n    else if (elements.length == 0) {\n      return whenNotFound()\n    }\n    else {\n      return whenMultipleFound(elements.length)\n    }\n  }\n\n  /** Access elements relvative to this component's element based on\n   *  a selector as you'd use for querySelectorAll(), but with the requirement\n   *  that at least one element be found.\n   *\n   *  @param {String} selector - A selector compatible wiht querySelectorAll or querySelector\n   *  @param {external:Element} baseElement - if omitted, uses this component's element. If given, uses it\n   *                as the basis for the search.\n   *                  \n   *  @returns {external:Element[]} the elements located\n   *  @throws an error if no elements matched\n   */\n  $selectors(selector,baseElement) {\n    if (!baseElement) {\n      baseElement = this.element\n    }\n\n    const elements = baseElement.querySelectorAll(selector)\n    if (elements.length == 0) {\n      throw `Expected ${selector} to return 1 or more elements, but matched 0 from ${baseElement}`\n    }\n    return elements;\n  }\n\n  /** Calls $selector with `[data-${dataAttribute}]` */\n  $(dataAttribute,baseElement,whenNotFound) { \n    return this.$selector(`[data-${dataAttribute}]`,baseElement, whenNotFound)\n  }\n  \n  /** Calls $selector with `[slot=name='${slotName}']` */\n  $slot(slotName,baseElement,whenNotFound) { \n    return this.$selector(`slot[name='${slotName}']`,baseElement, whenNotFound)\n  }\n\n  /** Calls $selectors with `slot[name='${slotName}']` */\n  $slots(slotName,baseElement) { \n    return this.$selectors(`slot[name='${slotName}']`,baseElement)\n  }\n\n}\nexport default WrapsElement\n", "import WrapsElement from \"./WrapsElement\"\n/**\n * A convienience for wrapping the body element.  This is handy as a starting point for locating\n * elements to wrap inside components.\n */\nclass Body extends WrapsElement {\n  constructor() {\n    super(document.body)\n  }\n}\n\nexport default Body\n", "import WrapsElement from \"./WrapsElement\"\n\n/**\n * Simplifies creating new DOM elements from `template` elements.\n *\n * Given a `template`, it's common to want to use it to create a new node, and to\n * prefill that nodes slots with dynamic information. For example, you may have\n * a template for a table row where each cell is a slot that needs data for that\n * row inserted.  This class helps manage that process.\n */\nclass Template extends WrapsElement {\n  /**\n   * Create a Template with the given element. Note that the element *must*\n   * be a `template` element.\n   *\n   * @param {external:Element} element - Element that this will wrap. It must be a `template` element.\n   */\n  constructor(element) {\n    super(element)\n    if (this.element.tagName != \"TEMPLATE\") {\n      throw `You may not create a Template from a ${this.element.tagName}`\n    }\n  }\n\n  /**\n   * Create a new `Node` based on this template. The new node will\n   * optionally have any slots it contains filled with values. This Node can be inserted into the DOM.\n   *\n   * @param {Object} options\n   * @param {Object} options.fillSlots - if present, this is an object where the property names are assumed to be slots with that name and the values are to be set as the innerText of the slot.  Each element of this object *must* be a slot inside the template. There can be more than one slot with any name and all will be filled in.\n   *\n   * @returns {external:Node} a new Node, filled with `options.fillSlots`, ready to be inserted into the DOM. \n   */\n  newNode(options) {\n    this.methodStart(\"newNode\")\n    const node = this.element.content.firstElementChild.cloneNode(true)\n    this.event(\"newNode\", { fillSlots: options ? options.fillSlots : undefined })\n    if (options && options.fillSlots) {\n      Object.entries(options.fillSlots).forEach( ([name,value]) => {\n        this.$slots(name,node).forEach( (slot) => {\n          slot.innerText = value\n        })\n      })\n    }\n    this.methodDone(\"newNode\")\n    return node\n  }\n}\nexport default Template\n", "import Template        from \"./Template\"\nimport WrapsElement    from \"./WrapsElement\"\n\n\n/**\n * Wraps an external:Element that is intended to be some sort of interactive\n * part of the UI. A Component is the building block of any dynamic element\n * and the intention is that you provide an implementation that wraps a DOM\n * element with a vastly simplified API.\n *\n * For example, an `HTMLFormElement` supports many events and actions. \n * If you have a button, you likely only care about the clicked event. You may\n * also prefer to model enable/disable directly.  Thus, you'd extend `Component`\n * and provide a `Button` class for how you want buttons to work.\n *\n * Most of the methods of this class are helpers to be used internally by subclasses.\n *\n * Extendors should avoid creating a constructor and instead implement `wasCreated`. This\n * method will be called by the constructor with whatever arguments are given to the constructor\n * other than the wrapped element.  This is to make it easier to create a construction\n * routine without having to remember to do `super(element)` every time.\n *\n * @example\n * // Given this markup:\n * // \n * //   <header>\n * //     <h1>Message</h1>\n * //     <a href=\"#\">Show / Hide</a>\n * //   </header>\n * // \n * // allow the href to show/hide the h1\n *\n * class HideableHeading extends Component {\n *   wasCreated() {\n *     this.title = this.$selector(\"h1\")\n *     this.link = new Link(this.$selector(\"a\"))\n *     this.link.onClick( () => this.title.toggle() )\n *   }\n * }\n *\n * const heading = new HideableHeading(body.$selector(\"header\"))\n *\n * @extends WrapsElement\n *\n */\nclass Component extends WrapsElement {\n\n  /**\n   * Creates a new component\n   *\n   * @param {external:Element} element - an Element from a web page that this component wraps\n   * @param {...args} args - passed to the super class and then to `wasCreated` if implemented.\n   *\n   */\n  constructor(element, ...args) {\n    super(element, ...args)\n    this.element = element\n    this.hidden  = window.getComputedStyle(this.element).display === \"none\"\n  }\n\n  /**\n   * Creates a `Template` based on an element inside this component.\n   *\n   * A common pattern with dynamic UIs is to use a template element to create dynamic\n   * elements with actual data in them.  This method simplifies that by locating the\n   * template (which is assumed to exist or there is an error) and then returning\n   * an instance of `Template` that wraps the templated markup.\n   *\n   * @param {String} dataAttribute - if present, the name of a data attribute to identify the template. This will be combined with `data-` so you should omit that. If omitted, this will locate a `template` element.  In either case, there must be exactly one such element within this component's element (or the provided `baseElement`)\n   * @param {Element} baseElement - if present, this is used to locate the template.  If omitted, will use this component's wrapped element.\n   *\n   * @returns {Template} a Template instance wrapping the template element\n   */\n  template(dataAttribute,baseElement) { \n    const selector = dataAttribute ? `template[data-${dataAttribute}]` : \"template\"\n    return new Template(this.$selector(selector,baseElement))\n  }\n\n  /**\n   * Hides a component.\n   *\n   * It's common to want to hide or show components. This method can be called\n   * by others to hide the component. By default, the hiding is done via \n   * the CSS display property.  If an animator is configured, it is used instead.\n   *\n   * XXX: Change impl\n   */\n  hide() {\n    this.hidden = true\n    if (this.animator) {\n      this.animator.animateBackward()\n    }\n    else {\n      this.element.classList.remove(\"db\")\n      this.element.classList.add(\"dn\")\n    }\n  }\n\n  /**\n   * Shows a component.\n   *\n   * It's common to want to hide or show components. This method can be called\n   * by others to show the component. By default, the showing is done via \n   * the CSS display property.  If an animator is configured, it is used instead.\n   *\n   * XXX: Change impl\n   */\n  show() {\n    this.hidden = false\n    if (this.animator) {\n      this.animator.animateForward()\n    }\n    else {\n      this.element.classList.remove(\"dn\")\n      this.element.classList.add(\"db\")\n    }\n  }\n\n  /** Toggles the shown/hidden state */\n  toggle() {\n    if (this.hidden) {\n      this.show()\n    }\n    else {\n      this.hide()\n    }\n  }\n\n}\nexport default Component\n", "/**\n * Wraps a string to return a humanized version, which is basically capitalizing it.\n */\nclass HumanizedString {\n  /**\n   * @param {String} string - string to humanize\n   * @returns {HumanizedString} for the given string.\n   */\n  static for(string) { return new HumanizedString(string) }\n  /**\n   * Create a HumanizedString, coercing falsey values to the empty string\n   *\n   * @param {String} string - string to humanize. May be undefined.\n   */\n  constructor(string) {\n    string = `${string || \"\"}` // Force string coercion\n    this.string = string[0].toUpperCase() + string.slice(1)\n  }\n\n  /** @returns {String} the humanized string */\n  toString() {\n    return this.string\n  }\n}\nexport default HumanizedString\n", "/**\n * Thrown when an event has already been defined on a class.\n *\n * @property {String} eventName - name of the event that was attempted to be defined\n * @property {String} propertyNameFound - the name of that property that was found. This name is derived from eventName and tells\n * you the specific property that the EventManager was trying to create.\n *\n * @see EventManager\n */\nclass EventAlreadyDefined extends Error {\n  constructor(eventName,propertyNameFound) {\n    super(`${eventName} appears to have already been defined - found '${propertyNameFound}' defined`)\n    this.eventName = eventName\n    this.propertyNameFound = propertyNameFound\n  }\n}\nexport default EventAlreadyDefined\n", "import BrutalDOMBase       from \"./BrutalDOMBase\"\nimport HumanizedString     from \"./HumanizedString\"\nimport TypeOf              from \"./TypeOf\"\nimport EventAlreadyDefined from \"./EventAlreadyDefined\"\n\nconst debounce = (callback, wait) => {\n  let timeout;\n  return (...args) => {\n    const context = this;\n    clearTimeout(timeout);\n    timeout = setTimeout(() => {\n      callback.apply(context, args)\n    }, wait);\n  };\n}\n\n/**\n * Defines an event and handles setting up methods needed for an object o\n * handle this event and its listeners.\n *\n * @private\n */\nclass EventDefinition {\n  /**\n   * Create an EventDefinition, but don't add it to the object, yet.\n   *\n   * @param {Object} object - the object that will fire this event\n   * @param {String} name - name of the event\n   *\n   * @throws {EventAlreadyDefined} if the object already has this event defined or if the methods it will create conflict with existing methods.\n   */\n  constructor(object, name) {\n    this.object           = object\n    this.name             = name\n    this.eventManagerName = `${name}EventManager`\n    this.addListenerName  = `on${HumanizedString.for(name)}`\n\n    if (object[this.eventManagerName]) {\n      throw new EventAlreadyDefined(name,this.eventManagerName)\n    }\n    if (object[this.addListenerName]) {\n      throw new EventAlreadyDefined(name,this.addListenerName)\n    }\n  }\n\n  /**\n   * Create the event mechanism on the object.  This modified the object \n   * passed to the constructor so that it will have the onXXX method.\n   */\n  create() {\n    const eventManager = new EventManager(this.object,this.name)\n    this.object[this.eventManagerName] =  eventManager\n    this.object[this.addListenerName] = (listener) => {\n      eventManager.addListener(listener)\n    }\n    return eventManager\n  }\n}\n\n/**\n * Basic publish/subscribe class for modeling events and managing listeners.\n *\n * A core concept of the library is that your code should not rely on the\n * builtin EventTarget or Event APIs, as they are quite low level.  Rather,\n * your components would model explicit events such as `onClick` or\n * `onSubmit`.  The `EventManager` is provided to facilitate the implementation\n * of those events.\n *\n * @example\n * class Button extends Component {\n *   wasCreated() {\n *     this.clickEventManager = new EventManager(this,\"click\")\n *     this.element.addEventListener(\"click\", () => {\n *       this.clickEventManager.fireEvent()\n *     })\n *   }\n *\n *   onClick(listener) { this.clickEventManager.addListener(listener) }\n * }\n *\n * @example\n * class Button extends Component {\n *   wasCreated() {\n *     EventManager.defineEvents(this, \"click\")\n *   }\n * }\n *\n * const button = new Button(document.querySelector(\"button\"))\n * button.onClick( (event) => {\n *   // do whatever on a click\n * })\n */\nclass EventManager extends BrutalDOMBase {\n\n  /** Shortcut to creating event managers explcitly.\n   *\n   * Ideally used in the constructor of your class to define all\n   * the events that your class will broadcast.\n   *\n   * @param {Object} object - the object on which the events will be defined\n   * @param {...String} names - a list of names of events.  For each name, this method will define an EventManager\n   *         for that named event, and then a method on\u00ABname\u00BB (where name is upper-case camelized)\n   *         that will register the passed listener for that event.  To fire an event, use\n   *         the EventNamager. For example, a name like \"formSubmitted\" would create the method `onFormSubmitted` which\n   *         you could trigger by calling `this.formSubmittedEventManager.fireEvent()`\n   */\n  static defineEvents(object, ...names) {\n    names.map( (name) => {\n      return new EventDefinition(object,name)\n    }).forEach( (eventDefinition) => {\n      eventDefinition.create()\n    })\n  }\n\n  /**\n   * Create an EventManager attached to the given object for the given event name.\n   *\n   * @param {Object} object - the object that will be firing events. This is only used for logging.\n   * @param {String} eventName - the name of the event.  This is only used for logging.\n   */\n  constructor(object, eventName) {\n    super()\n    this.listeners = new Set()\n    this.eventName = eventName\n    this.objectClass = TypeOf.asString(object)\n  }\n\n  /** Adds a listener to this event. \n   *\n   * @param {EventManager~listener|EventManager} listener to be called when the event fires. If the listener is an instance of an\n   * EventManager, that manager's `fireEvent` method is called when this manager's is fired. This makes it simpler to proxy\n   * events.\n   */\n  addListener(listener) { this.listeners.add(listener) }\n\n  /** Remove a listener from this event. \n   *\n   * @param {EventManager~listener|EventManager} listener to be called when the event fires.\n   */\n  removeListener(listener) { return this.listeners.delete(listener) }\n\n  /**\n   * Modifies this EventManager to debounce its fireEvent methods by timeoutMS milliseconds.\n   *\n   * @param {int} timeoutMS - Milliseconds to debounce the fireEvent method. If 0, debouncing is removed.\n   */\n  debounce(timeoutMS) {\n    if (timeoutMS == 0) {\n      delete this._debouncedFireEvent\n    }\n    else {\n      this._debouncedFireEvent = debounce(this._fireEvent.bind(this), timeoutMS)\n    }\n  }\n\n  /**\n   * Called with whatever arguments were given to fireEvent.\n   * @callback EventManager~listener\n   */\n\n  /** Fire the event, passing each listener the given args.\n   *\n   * @param {...Object} args - any args relevant to the event. You should document what these are.\n   */\n  fireEvent(...args) {\n    if (this._debouncedFireEvent) {\n      this.event(\"usingDebounced\",{})\n      this._debouncedFireEvent(...args)\n    }\n    else {\n      this._fireEvent(...args)\n    }\n  }\n\n  _fireEvent(...args) {\n    this.methodStart(\"fireEvent\", { listeners: this.listeners.size, eventName: this.eventName, objectClass: this.objectClass })\n    this.listeners.forEach( (listener) => {\n      if (TypeOf.asString(listener) == \"EventManager\") {\n        listener.fireEvent(...args)\n      }\n      else {\n        listener(...args)\n      }\n    })\n    this.methodDone(\"fireEvent\")\n  }\n\n  /**\n   * Creates an EventManager and related methods for an existing DOM event.  Calls preventDefault on\n   * the fired event before triggering listeners.\n   *\n   * @param object {Object} - the object that is firing the event\n   * @param {Object} namedParams\n   * @param {external:Element} namedParams.element - Element that will fire the event\n   * @param {String} namedParams.eventName - name of the event that the element will fire\n   *\n   * @example\n   * class Button extends Component {\n   *   constructor(element) {\n   *     super(element)\n   *     this.onClickEventManager = EventManager.createDirectProxyFor(\n   *       this,\n   *       {\n   *         element: this.element,\n   *         eventName: \"click\"\n   *       }\n   *     )\n   *   }\n   * }\n   *\n   * const button = new Button(document.querySelector(\"button\"))\n   * button.onClick( () => {\n   *   // whatever the button should do\n   *   // noting that preventDefault has been called\n   * })\n   *\n   */\n  static createDirectProxyFor(object,{element,eventName}) {\n    const eventDefinition = new EventDefinition(object,eventName)\n    const eventManager = eventDefinition.create()\n    element.addEventListener(eventName, (event) => {\n      event.preventDefault()\n      eventManager.fireEvent(event)\n    })\n  }\n}\n\nexport default EventManager\n", "import Component    from \"./Component\"\nimport EventManager from \"./EventManager\"\n\n/** Simple wrapper for a link that exposes an onClick event that preventsDefault. */\nclass Link extends Component {\n  wasCreated() {\n    this.clickEventManager = EventManager.createDirectProxyFor(this, { element: this.element, eventName: \"click\" })\n  }\n\n  \n}\nexport default Link\n", "/**\n * Wrapper around which stage or environment the code is running in.  For example, this class will tell you\n * if you are running in test or production mode.\n */\nclass Env {\n  /**\n   * Create the Env\n   *\n   * @param {String} string - name of the env. Must be a known name.\n   * @throw if string is not a known environment\n   */\n  constructor(string) {\n    if ( (string === \"dev\") ||\n         (string === \"test\") ||\n         (string === \"production\") ) {\n      this.string = string\n    }\n    else {\n      throw `'${string}' is not a valid ENV`\n    }\n  }\n\n  /** @return true if we are running in the test environment */\n  isTest()       { return this.string == \"test\" }\n  /** @return true if we are running in the dev environment */\n  isDev()        { return this.string == \"dev\" }\n  /** @return true if we are running in the production environment */\n  isProduction() { return this.string == \"production\" }\n\n  toString() { return this.string }\n}\n\nexport default Env\n\n", "import BrutalDOMBase from \"./BrutalDOMBase\"\nimport Env           from \"./Env\"\n\n/**\n * Provides access to information about the runtime of the app.\n *\n * @see Env\n */\nclass Runtime extends BrutalDOMBase {\n  /** @returns {Runtime} the only instance of this class */\n  static instance() {\n    if (!this._instance) {\n      this._instance = new Runtime()\n    }\n    return this._instance\n  }\n  /** @returns {Env} the env you are running in */\n  static env() {\n    return this.instance().env\n  }\n\n  /**\n   * Create the runtime.  This assumes that a global variable named `ENV` is defined somewhere and that it\n   * has a value compatible with the Env class' constructor.\n   *\n   * If no such `ENV` variable exists, it will assuming it's running in the dev environment.\n   *\n   * @see Env\n   */\n  constructor() {\n    super()\n    if (typeof ENV !== \"undefined\") {\n      this.env = new Env(ENV)\n    }\n    else {\n      this.env = new Env(\"dev\")\n    }\n    this.event(\"runtimeConfigured\", { env: this.env.toString() })\n  }\n}\n\nexport default Runtime;\n", "import Runtime from \"./Runtime\"\n\nclass DetailAttributeFilter {\n  constructor(attributeName, attributeValues) {\n    this.attributeName  = attributeName\n    this.attributeValues = Array.isArray(attributeValues) ? attributeValues : [ attributeValues ]\n    this.all = attributeValues === \"ALL\"\n  }\n  entryFilter() {\n    if (this.all) {\n      return () => { return true }\n    }\n    return (entry) => {\n      return entry.detail && this.attributeValues.indexOf(entry.detail[this.attributeName]) != -1\n    }\n  }\n  excludeDetail(key,value) {\n    return key == this.attributeName\n  }\n}\n\nclass FancyConsoleLogger {\n  constructor(detailFilters) {\n    this.detailFilters = detailFilters\n  }\n  log(entry) {\n    const detail = entry.detailFiltered(this.detailFilters)\n\n    let additional = null\n    if (entry.attributeName) {\n      additional = `${entry.attributeName}: ${entry.attributeValue}${entry.attributeUnits}`\n    }\n    const consoleArgs = [\n      \"%s\\t%c%s %c%s\",\n      entry.char,\n      \"text-weight: bold; font-family: monospace; color: #00a\",\n      entry.name,\n      \"text-weight: bold; color: #0a4\",\n      additional,\n    ]\n    if (Object.entries(detail).length != 0) {\n      console.groupCollapsed(...consoleArgs)\n      console.log(\"%o\",detail)\n      console.groupEnd()\n    }\n    else {\n      console.log(...consoleArgs)\n    }\n  }\n}\nclass BasicConsoleLogger {\n  constructor(detailFilters) {\n    this.detailFilters = detailFilters\n  }\n  log(entry) {\n    const detail = entry.detailFiltered(this.detailFilters)\n\n    const logInfo = {\n      type: entry.type,\n      name: entry.name,\n    }\n    if (entry.attributeName) {\n      logInfo[entry.attributeName] = `${entry.attributeValue}${entry.attributeUnits}`\n    }\n    if (Object.entries(detail).length != 0) {\n      logInfo.detail = JSON.stringify(detail)\n    }\n    console.log(Object.entries(logInfo).map( ([key,value]) => {\n      return `${key}: '${value}'`\n    }).join(\"; \"))\n  }\n}\n\nclass WrappedEntry {\n  constructor(entry) {\n    this.entry = entry\n    this.name = entry.name\n    this.type = entry.entryType\n  }\n  detailFiltered(detailFilters) {\n    const detail = {}\n    Object.entries(this.entry.detail || {}).forEach( ([key,value]) => {\n      const exclude = detailFilters.find( (filter) => {\n        return filter.excludeDetail(key,value)\n      })\n      if (!exclude) {\n        detail[key] = value\n      }\n    })\n    return detail\n  }\n}\n\nclass Mark extends WrappedEntry {\n  constructor(entry) {\n    super(entry)\n    this.char = \"\u26F3\uFE0F\"\n  }\n}\nclass Measure extends WrappedEntry {\n  constructor(entry) {\n    super(entry)\n    this.char = \"\u23F1\"\n    this.attributeName = \"duration\"\n    this.attributeValue = this.entry.duration\n    this.attributeUnits = \"ms\"\n  }\n}\n\nlet ConsoleLogger = FancyConsoleLogger\nif (Runtime.env().isTest()) {\n  ConsoleLogger = BasicConsoleLogger\n}\n\nclass MarkType {\n  constructor(detailFilters) {\n    this.consoleLogger = new ConsoleLogger(detailFilters)\n    this.typeFilter = (entry) => entry.entryType == \"mark\"\n  }\n  consoleLog(entry) { this.consoleLogger.log(new Mark(entry)) }\n}\n\nclass MeasureType {\n  constructor(detailFilters) {\n    this.consoleLogger = new ConsoleLogger(detailFilters)\n    this.typeFilter = (entry) => entry.entryType == \"measure\"\n  }\n\n  consoleLog(entry) { this.consoleLogger.log(new Measure(entry)) }\n}\n\n/**\n * An interface to allow viewing of the log entries sent using Log and the Performance API.  Under the covers, this\n * uses a PerformanceObserver to receive the messages.\n *\n * @see external:PerformanceObserver\n */\nclass LogViewer { // DO NOT EXTEND BrutalDOMBase\n  /**\n   * Create a LogViewer.\n   *\n   * @param {Object} namedParams\n   * @param {String} namedParams.logContext - Ignore log messages that don't match this context.  The special value \"ALL\" means to\n   * show all log messages.  Otherwise, this is used to filter messages that have both have details and have a logContext key\n   * in the details.  If the value of that key includes this value, the message is shown. Otherwise it is filtered out.  Note\n   * that any class that mixes in the Log mixin can set its context for messages it logs by setting the logContext static\n   * property.  This is useful to tag a group of classes or module.\n   * @param {String} namedParams.className - Filter for only messages from a certain class.  Like logContext, this works by matching\n   * on the details value and the className key, which is set automatically by any class using the Log mixin.  The value \"ALL\" means\n   * to shnow all classes.\n   * @param {String} type if \"BOTH\" then both marks and measures are shown. If mark, only marks are shown. If measure, only measures\n   * are shown.\n   */\n  constructor({ logContext = \"ALL\", className = \"ALL\", type = \"BOTH\" } = {}) {\n\n    const logContextFilter = new DetailAttributeFilter(\"logContext\",logContext)\n    const classNameFilter  = new DetailAttributeFilter(\"className\",className)\n\n    const detailFilters = [\n      logContextFilter,\n      classNameFilter,\n    ]\n\n    const types = {\n      mark: new MarkType(detailFilters),\n      measure: new MeasureType(detailFilters),\n    }\n\n    let typeFilter = () => { return true }\n    if (type !== \"BOTH\") {\n      typeFilter = types[type].typeFilter\n    }\n\n    this.observer = new PerformanceObserver( (list,observer) => {\n      list.getEntries().\n        filter(typeFilter).\n        filter(logContextFilter.entryFilter()).\n        filter(classNameFilter.entryFilter()).\n        forEach( (entry) => {\n          types[entry.entryType].consoleLog(entry)\n        })\n    })\n  }\n  /**\n   * Start the observer. Without calling this, no messages will be viewed.\n   */\n  start() {\n    this.observer.observe({ entryTypes: [\"measure\", \"mark\"] })\n  }\n}\nexport default LogViewer\n", "import { Body, Link } from \"brutaldom\"\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const body = new Body()\n  const startButton = new Link(body.$(\"start\"))\n  const exercise = body.$(\"exercise\")\n  startButton.onClick( () => {\n    exercise.requestFullScreen({\n      navigationUI: \"hide\",\n    }).then( () => {\n      console.log(\"FULLSCREEN\")\n    }).catch( (e) => {\n      console.error(e)\n      alert(\"WAT\")\n    })\n  })\n})\n"],
  "mappings": "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",
  "names": []
}
